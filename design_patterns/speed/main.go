package main

//最常用到几个评判代码质量的标准有:可维护性、可读性、可扩展性、灵活性、简洁性、可复用性、可测试 性。其中，可维护性、可读性、可扩展性又是提到最多的、最重要的三个评价标准。

/*
重构的目的:为什么重构(why)
重构的对象:重构什么(what):
 大规模高层次重构 包括对代码分层、模块化、解耦、梳理类之间的交互关系、抽象复用组件等等。
 小规模低层次的重构包括规范命名、注释、修正函数参数过 多、消除超大类、提取重复代码等编程细节问题，主要是针对类、函数级别的重构。
重构的时机:什么时候重构(when)
重构的方法:如何重构(how)
 */

/*
封装特性存在的意义，一方面是保护数据不被随意修改，提高代码的可维护性;另一方面是 仅暴露有限的必要接口，提高类的易用性。
抽象存在的意义，一方面是修改实现不需要改变定义;另一方面，它也是处理复杂系统的有效手段，能有效地过滤 掉不必要关注的信息。
继承主要是用来解决代码复用的问题。
多态可以提高代码的扩展性和复用性， 是很多设计模式、设计原则、编程技巧的代码实现基础。

面向对象分析(OOA)、面向对象设计(OOD)、面向对象编程(OOP)
面向对象分析就是要搞清楚做什么，面向对象设计就是要搞清楚怎么做，面向对象编程就是 将分析和设计的的结果翻译成代码的过程。
1.划分职责进而识别出有哪些类: 根据需求描述，我们把其中涉及的功能点，一个一个罗列出来，然后再去看哪些功能点职责相近，操作同样的属性，可否归为同一个类。
2.定义类及其属性和方法: 识别出需求描述中的动词，作为候选的方法，再进一步过滤筛选出真正的方法，把功能点中涉及的名 词，作为候选属性，然后同样再进行过滤筛选。
3.定义类与类之间的交互关系: 泛化、实现、关联、聚合、组合、依赖。我们从更加贴近编程的⻆度，对类与类之间的关系做了调整，保留了四个关系:泛化、实现、组合、依赖。
4.将类组装起来并提供执行入口: 将所有的类组装在一起，提供一个执行入口。

抽象类是对成员变量和方法的抽象，是一种is-a关系，是为了解决代码复用问题。接口仅仅是对方法的抽 象，是一种has-a关系，表示具有某一组行为特性，是为了解决解耦问题，隔离接口和具体的实现，提高代 码的扩展性。
基于接口而非实现编程可以将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。

多用组合少用继承:
继承层次过深、过复杂，也会影响到代码的可维护性。
继承主要有三个作用:表示is-a关系、支持多态特性、代码复用。而这三个作用都可以通过组合、接口、委托三个技术手段来达成。除此之外，利用组合还能解决层次过深、过复杂的继承关系影响代码可维护性的问题。

贫血模型VS充血模型:
充血模型的DDD开发模式跟基于贫血模型的传统开发模式相比，主要区别在Service层。在基于充血模 型的开发模式下，我们将部分原来在Service类中的业务逻辑移动到了一个充血的Domain领域模型中，让 Service类的实现依赖这个Domain类。
 */

/*
最快速地改善代码质量:
命名:
1.准确达意
2.利用上下文简化命名
3.命名要可读、可搜索
4.对于接口的命名:一种是加前缀“I”, 比如 IUserService。另一种是不加前缀，对应的实现类加 后缀“Impl”，比如UserServiceImpl。
5.抽象类的命名: 带上前缀“Abstract”，比如AbstractConfiguration。
注释:
 1.注释包含三个方面: 做什么、为什么、怎么做
 2.注释太多和太少都有问题
类、函数多大才合适:
 1.当一个类的代码读起来让你感觉头大了，实现某个功能时不知道该用哪个函数了，想用哪个函数翻半天都找不到了，只用到一个小功能要引入整个类(类中包含很多无关此功能实现的函数)的时候， 这就说明类的行数过多了。
 2.函数代码行数的最大限制，不要超过一个显示屏的垂直高度。
 3.一行代码最⻓不能超过IDE显示的宽度。
 4.在类的成员变量与函数之间、静态成员变量与普通成员变量之间、各函数之间、甚至各成员变量 \之间，我们都可以通过添加空行的方式，让这些不同模块的代码之间，界限更加明确。
把代码分割成更小的单元块:
避免函数参数过多:最好不要大于等于5个，解决办法。
 1.考虑函数是否职责单一，是否能通过拆分成多个函数的方式来减少参数。
 2.将函数的参数封装成对象。
勿用函数参数来控制逻辑:建议将其拆成多个函数，可读性上也要更好。
函数设计要职责单一:
移除过深的嵌套层次:
 1.去掉多余的if或else语句。
 2.使用编程语言提供的continue、break、return关键字，提前退出嵌套。
 3.调整执行顺序来减少嵌套。
 4.将部分嵌套逻辑封装成函数调用，以此来减少嵌套。
学会使用解释性变量:
 1.常量取代魔法数字。
 2.使用解释性变量来解释复杂表达式。
*/

/*
发现代码质量问题:
目录设置是否合理、模块划分是否清晰、代码结构是否满足“高内聚、松耦合”?
是否遵循经典的设计原则和设计思想(SOLID、DRY、KISS、YAGNI、LOD等)? 设计模式是否应用得当?是否有过度设计?
代码是否容易扩展?如果要添加新功能，是否容易实现?
代码是否可以复用?是否可以复用已有的项目代码或类库?是否有重复造轮子?
代码是否容易测试?单元测试是否全面覆盖了各种正常和异常的情况?
代码是否易读?是否符合编码规范(比如命名和注释是否恰当、代码⻛格是否一致等)?

代码是否实现了预期的业务需求?
逻辑是否正确?是否处理了各种异常情况?
日志打印是否得当?是否方便debug排查问题?
接口是否易用?是否支持幂等、事务等?
代码是否存在并发问题?是否线程安全?
性能是否有优化空间，比如，SQL、算法是否可以优化?
是否有安全漏洞?比如输入输出校验是否全面?
 */

/*
 重构步骤:
 第一轮重构:提高代码的可读性
 第二轮重构:提高代码的可测试性
 第三轮重构:编写完善的单元测试
 第四轮重构:所有重构完成之后添加注释
 */

/*
 函数出错应该返回什么: 错误码、NULL值、空对象、异常对象。
 1.返回代表不存在语义的NULL值比返回异常更加合理，其他场合尽量避免可能会抛出空指针异常。
 2.尽量使用异常不使用错误码，因为携带信息更多。
 3.异常的三种处理方法:直接吞掉、直接往上抛出、包裹成新的异常抛出。
 */
func main() {

}
